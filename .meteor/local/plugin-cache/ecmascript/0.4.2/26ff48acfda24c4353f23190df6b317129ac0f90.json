{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ongoworks:security/lib/server/Security.js","filenameRelative":"/packages/ongoworks:security/lib/server/Security.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ongoworks:security/lib/server/Security.js.map","sourceFileName":"/packages/ongoworks:security/lib/server/Security.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"Security"},"ignored":false,"code":"// The `Security` object is exported and provides the package API\nSecurity = {\n  // Putting these on the exported object allows package users to override if necessary\n  errorMessages: {\n    multipleCan: 'You may not combine more than one insert, update, or remove on a Security.can chain',\n    notAllowed: 'Action not allowed',\n    requiresDefinition: 'Security.defineMethod requires a \"definition\" argument',\n    requiresAllow: 'Security.defineMethod requires an \"allow\" function',\n    collectionsArg: 'The collections argument must be a Mongo.Collection instance or an array of them',\n    noCollectionOrType: 'At a minimum, you must call permit and collections methods for a security rule.'\n  },\n  // the starting point of the chain\n  permit: function () {\n    function permit(types) {\n      return new Security.Rule(types);\n    }\n\n    return permit;\n  }(),\n  can: function () {\n    function can(userId) {\n      return new Security.Check(userId);\n    }\n\n    return can;\n  }(),\n  defineMethod: function () {\n    function securityDefineMethod(name, definition) {\n      // Check whether a rule with the given name already exists; can't overwrite\n      if (Security.Rule.prototype[name]) {\n        throw new Error('A security method with the name \"' + name + '\" has already been defined');\n      }\n      if (!definition) throw new Error(Security.errorMessages.requiresDefinition);\n      // If \"deny\" is used, convert to \"allow\" for backwards compatibility\n      if (definition.deny) {\n        definition.allow = function () {\n          return !definition.deny.apply(definition, arguments);\n        };\n      }\n      // Make sure the definition argument is an object that has an `allow` property\n      if (!definition.allow) throw new Error(Security.errorMessages.requiresAllow);\n      // Wrap transform, if provided\n      if (definition.transform) {\n        definition.transform = LocalCollection.wrapTransform(definition.transform);\n      }\n      Security.Rule.prototype[name] = function (arg) {\n        this._restrictions.push({\n          definition: definition,\n          arg: arg\n        });\n        return this;\n      };\n    }\n\n    return securityDefineMethod;\n  }()\n};\n\nMongo.Collection.prototype.permit = function (types) {\n  return Security.permit(types).collections(this);\n};","ast":null,"map":{"version":3,"sources":["/packages/ongoworks:security/lib/server/Security.js"],"names":[],"mappings":";AACA,WAAW;;AAET,iBAAe;AACb,iBAAa,qFAAb;AACA,gBAAY,oBAAZ;AACA,wBAAoB,wDAApB;AACA,mBAAe,oDAAf;AACA,oBAAgB,kFAAhB;AACA,wBAAoB,iFAApB;GANF;;AASA;AAAQ,aAAS,MAAT,CAAgB,KAAhB,EAAuB;AAC7B,aAAO,IAAI,SAAS,IAAT,CAAc,KAAlB,CAAP,CAD6B;KAAvB;;WAAS;KAAjB;AAGA;AAAK,aAAS,GAAT,CAAa,MAAb,EAAqB;AACxB,aAAO,IAAI,SAAS,KAAT,CAAe,MAAnB,CAAP,CADwB;KAArB;;WAAS;KAAd;AAGA;AAAc,aAAS,oBAAT,CAA8B,IAA9B,EAAoC,UAApC,EAAgD;;AAE5D,UAAI,SAAS,IAAT,CAAc,SAAd,CAAwB,IAAxB,CAAJ,EAAmC;AACjC,cAAM,IAAI,KAAJ,CAAU,sCAAsC,IAAtC,GAA6C,4BAA7C,CAAhB,CADiC;OAAnC;AAGA,UAAI,CAAC,UAAD,EAAa,MAAM,IAAI,KAAJ,CAAU,SAAS,aAAT,CAAuB,kBAAvB,CAAhB,CAAjB;;AAL4D,UAOxD,WAAW,IAAX,EAAiB;AACnB,mBAAW,KAAX,GAAmB,YAAa;AAC9B,iBAAO,CAAC,WAAW,IAAX,6BAAD,CADuB;SAAb,CADA;OAArB;;AAP4D,UAaxD,CAAC,WAAW,KAAX,EAAkB,MAAM,IAAI,KAAJ,CAAU,SAAS,aAAT,CAAuB,aAAvB,CAAhB,CAAvB;;AAb4D,UAexD,WAAW,SAAX,EAAsB;AACxB,mBAAW,SAAX,GAAuB,gBAAgB,aAAhB,CAA8B,WAAW,SAAX,CAArD,CADwB;OAA1B;AAGA,eAAS,IAAT,CAAc,SAAd,CAAwB,IAAxB,IAAgC,UAAU,GAAV,EAAe;AAC7C,aAAK,aAAL,CAAmB,IAAnB,CAAwB;AACtB,gCADsB;AAEtB,kBAFsB;SAAxB,EAD6C;AAK7C,eAAO,IAAP,CAL6C;OAAf,CAlB4B;KAAhD;;WAAS;KAAvB;CAjBF;;AA6CA,MAAM,UAAN,CAAiB,SAAjB,CAA2B,MAA3B,GAAoC,UAAU,KAAV,EAAiB;AACnD,SAAO,SAAS,MAAT,CAAgB,KAAhB,EAAuB,WAAvB,CAAmC,IAAnC,CAAP,CADmD;CAAjB","file":"/packages/ongoworks:security/lib/server/Security.js.map","sourcesContent":["// The `Security` object is exported and provides the package API\nSecurity = {\n  // Putting these on the exported object allows package users to override if necessary\n  errorMessages: {\n    multipleCan: 'You may not combine more than one insert, update, or remove on a Security.can chain',\n    notAllowed: 'Action not allowed',\n    requiresDefinition: 'Security.defineMethod requires a \"definition\" argument',\n    requiresAllow: 'Security.defineMethod requires an \"allow\" function',\n    collectionsArg: 'The collections argument must be a Mongo.Collection instance or an array of them',\n    noCollectionOrType: 'At a minimum, you must call permit and collections methods for a security rule.',\n  },\n  // the starting point of the chain\n  permit: function permit(types) {\n    return new Security.Rule(types);\n  },\n  can: function can(userId) {\n    return new Security.Check(userId);\n  },\n  defineMethod: function securityDefineMethod(name, definition) {\n    // Check whether a rule with the given name already exists; can't overwrite\n    if (Security.Rule.prototype[name]) {\n      throw new Error('A security method with the name \"' + name + '\" has already been defined');\n    }\n    if (!definition) throw new Error(Security.errorMessages.requiresDefinition);\n    // If \"deny\" is used, convert to \"allow\" for backwards compatibility\n    if (definition.deny) {\n      definition.allow = (...args) => {\n        return !definition.deny(...args);\n      };\n    }\n    // Make sure the definition argument is an object that has an `allow` property\n    if (!definition.allow) throw new Error(Security.errorMessages.requiresAllow);\n    // Wrap transform, if provided\n    if (definition.transform) {\n      definition.transform = LocalCollection.wrapTransform(definition.transform);\n    }\n    Security.Rule.prototype[name] = function (arg) {\n      this._restrictions.push({\n        definition,\n        arg,\n      });\n      return this;\n    };\n  }\n};\n\nMongo.Collection.prototype.permit = function (types) {\n  return Security.permit(types).collections(this);\n};\n"]},"hash":"26ff48acfda24c4353f23190df6b317129ac0f90"}
