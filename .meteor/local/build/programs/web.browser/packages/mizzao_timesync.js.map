{"version":3,"sources":["meteor://ðŸ’»app/packages/mizzao:timesync/timesync-client.js"],"names":[],"mappings":"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","file":"/packages/mizzao_timesync.js","sourcesContent":["//IE8 doesn't have Date.now()\nDate.now = Date.now || function() { return +new Date; };\n\nTimeSync = {\n  loggingEnabled: true\n};\n\nfunction log(/* arguments */) {\n  if (TimeSync.loggingEnabled) {\n    Meteor._debug.apply(this, arguments);\n  }\n}\n\nvar defaultInterval = 1000;\n\n// Internal values, exported for testing\nSyncInternals = {\n  offset: undefined,\n  roundTripTime: undefined,\n  offsetDep: new Deps.Dependency(),\n  timeTick: {},\n\n  timeCheck: function (lastTime, currentTime, interval, tolerance) {\n    if (Math.abs(currentTime - lastTime - interval) < tolerance) {\n      // Everything is A-OK\n      return true;\n    }\n    // We're no longer in sync.\n    return false;\n  }\n};\n\nSyncInternals.timeTick[defaultInterval] = new Deps.Dependency();\n\nvar maxAttempts = 5;\nvar attempts = 0;\n\n/*\n  This is an approximation of\n  http://en.wikipedia.org/wiki/Network_Time_Protocol\n\n  If this turns out to be more accurate under the connect handlers,\n  we should try taking multiple measurements.\n */\n\nvar syncUrl;\nif (Meteor.isCordova) {\n  // Only use Meteor.absoluteUrl for Cordova; see\n  // https://github.com/meteor/meteor/issues/4696\n  // https://github.com/mizzao/meteor-timesync/issues/30\n  // Cordova should never be running out of a subdirectory...\n  syncUrl = Meteor.absoluteUrl(\"_timesync\");\n}\nelse {\n  // Support Meteor running in relative paths, based on computed root url prefix\n  // https://github.com/mizzao/meteor-timesync/pull/40\n  const basePath = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || '';\n  syncUrl = basePath + \"/_timesync\";\n}\n\nvar updateOffset = function() {\n  var t0 = Date.now();\n\n  HTTP.get(syncUrl, function(err, response) {\n    var t3 = Date.now(); // Grab this now\n    if (err) {\n      //  We'll still use our last computed offset if is defined\n      log(\"Error syncing to server time: \", err);\n      if (++attempts <= maxAttempts)\n        Meteor.setTimeout(TimeSync.resync, 1000);\n      else\n        log(\"Max number of time sync attempts reached. Giving up.\");\n      return;\n    }\n\n    attempts = 0; // It worked\n\n    var ts = parseInt(response.content);\n    SyncInternals.offset = Math.round(((ts - t0) + (ts - t3)) / 2);\n    SyncInternals.roundTripTime = t3 - t0; // - (ts - ts) which is 0\n    SyncInternals.offsetDep.changed();\n  });\n};\n\n// Reactive variable for server time that updates every second.\nTimeSync.serverTime = function(clientTime, interval) {\n  check(interval, Match.Optional(Match.Integer));\n  // If we don't know the offset, we can't provide the server time.\n  if ( !TimeSync.isSynced() ) return undefined;\n  // If a client time is provided, we don't need to depend on the tick.\n  if ( !clientTime ) getTickDependency(interval || defaultInterval).depend();\n\n  // SyncInternals.offsetDep.depend(); implicit as we call isSynced()\n  // Convert Date argument to epoch as necessary\n  return (+clientTime || Date.now()) + SyncInternals.offset;\n};\n\n// Reactive variable for the difference between server and client time.\nTimeSync.serverOffset = function() {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.offset;\n};\n\nTimeSync.roundTripTime = function() {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.roundTripTime;\n};\n\nTimeSync.isSynced = function() {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.offset !== undefined;\n};\n\nvar resyncIntervalId = null;\n\nTimeSync.resync = function() {\n  if (resyncIntervalId !== null) Meteor.clearInterval(resyncIntervalId);\n  updateOffset();\n  resyncIntervalId = Meteor.setInterval(updateOffset, 600000);\n};\n\n// Run this as soon as we load, even before Meteor.startup()\n// Run again whenever we reconnect after losing connection\nvar wasConnected = false;\n\nDeps.autorun(function() {\n  var connected = Meteor.status().connected;\n  if ( connected && !wasConnected ) TimeSync.resync();\n  wasConnected = connected;\n});\n\n// Resync if unexpected change by more than a few seconds. This needs to be\n// somewhat lenient, or a CPU-intensive operation can trigger a re-sync even\n// when the offset is still accurate. In any case, we're not going to be able to\n// catch very small system-initiated NTP adjustments with this, anyway.\nvar tickCheckTolerance = 5000;\n\nvar lastClientTime = Date.now();\n\n// Set up a new interval for any amount of reactivity.\nfunction getTickDependency(interval) {\n\n  if ( !SyncInternals.timeTick[interval] ) {\n    var dep  = new Deps.Dependency();\n\n    Meteor.setInterval(function() {\n      dep.changed();\n    }, interval);\n\n    SyncInternals.timeTick[interval] = dep;\n  }\n\n  return SyncInternals.timeTick[interval];\n}\n\n// Set up special interval for the default tick, which also watches for re-sync\nMeteor.setInterval(function() {\n  var currentClientTime = Date.now();\n\n  if ( SyncInternals.timeCheck(\n    lastClientTime, currentClientTime, defaultInterval, tickCheckTolerance) ) {\n    // No problem here, just keep ticking along\n    SyncInternals.timeTick[defaultInterval].changed();\n  }\n  else {\n    // resync on major client clock changes\n    // based on http://stackoverflow.com/a/3367542/1656818\n    log(\"Clock discrepancy detected. Attempting re-sync.\");\n    // Refuse to compute server time.\n    SyncInternals.offset = undefined;\n    SyncInternals.offsetDep.changed();\n    TimeSync.resync();\n  }\n\n  lastClientTime = currentClientTime;\n}, defaultInterval);\n\n"]}