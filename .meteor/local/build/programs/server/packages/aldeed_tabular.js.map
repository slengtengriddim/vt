{"version":3,"sources":["meteor://ðŸ’»app/packages/aldeed_tabular/common.js","meteor://ðŸ’»app/packages/aldeed_tabular/server/tabular.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/aldeed_tabular.js","sourcesContent":["/* global Tabular:true, Mongo, _, Meteor, Template */\n\nTabular = {}; //exported\n\nTabular.tablesByName = {};\n\nif (Meteor.isClient) {\n  Template.registerHelper('TabularTables', Tabular.tablesByName);\n}\n\nTabular.Table = function (options) {\n  var self = this;\n\n  if (!options) {\n    throw new Error('Tabular.Table options argument is required');\n  }\n\n  if (!options.name) {\n    throw new Error('Tabular.Table options must specify name');\n  }\n  self.name = options.name;\n\n  if (!(options.collection instanceof Mongo.Collection)) {\n    throw new Error('Tabular.Table options must specify collection');\n  }\n  self.collection = options.collection;\n\n  self.pub = options.pub || 'tabular_genericPub';\n\n  // By default we use core `Meteor.subscribe`, but you can pass\n  // a subscription manager like `sub: new SubsManager({cacheLimit: 20, expireIn: 3})`\n  self.sub = options.sub || Meteor;\n\n  self.onUnload = options.onUnload;\n  self.allow = options.allow;\n  self.allowFields = options.allowFields;\n  self.changeSelector = options.changeSelector;\n\n  if (_.isArray(options.extraFields)) {\n    var fields = {};\n    _.each(options.extraFields, function (fieldName) {\n      fields[fieldName] = 1;\n    });\n    self.extraFields = fields;\n  }\n\n  self.selector = options.selector;\n\n  if (!options.columns) {\n    throw new Error('Tabular.Table options must specify columns');\n  }\n\n  self.options = _.omit(options, 'collection', 'pub', 'sub', 'onUnload', 'allow', 'allowFields', 'extraFields', 'name', 'selector');\n\n  Tabular.tablesByName[self.name] = self;\n};\n","/* global check, Match, Meteor, _, Tabular */\n\n/*\n * These are the two publications used by TabularTable.\n *\n * The genericPub one can be overridden by supplying a `pub`\n * property with a different publication name. This publication\n * is given only the list of ids and requested fields. You may\n * want to override it if you need to publish documents from\n * related collections along with the table collection documents.\n *\n * The getInfo one runs first and handles all the complex logic\n * required by this package, so that you don't have to duplicate\n * this logic when overriding the genericPub function.\n *\n * Having two publications also allows fine-grained control of\n * reactivity on the client.\n */\n\nMeteor.publish(\"tabular_genericPub\", function (tableName, ids, fields) {\n  var self = this;\n\n  check(tableName, String);\n  check(ids, Array);\n  check(fields, Match.Optional(Object));\n\n  var table = Tabular.tablesByName[tableName];\n  if (!table) {\n    // We throw an error in the other pub, so no need to throw one here\n    self.ready();\n    return;\n  }\n\n  // Extend fields list with extra fields from the table definition\n  if (table.extraFields) {\n    _.extend(fields, table.extraFields);\n  }\n\n  // Check security. We call this in both publications.\n  if (typeof table.allow === 'function' && !table.allow(self.userId, fields)) {\n    self.ready();\n    return;\n  }\n\n  // Check security for fields. We call this only in this publication\n  if (typeof table.allowFields === 'function' && !table.allowFields(self.userId, fields)) {\n    self.ready();\n    return;\n  }\n\n  return table.collection.find({_id: {$in: ids}}, {fields: fields});\n});\n\nMeteor.publish(\"tabular_getInfo\", function(tableName, selector, sort, skip, limit) {\n  var self = this;\n\n  check(tableName, String);\n  check(selector, Match.Optional(Match.OneOf(Object, null)));\n  check(sort, Match.Optional(Match.OneOf(Array, null)));\n  check(skip, Number);\n  check(limit, Match.Optional(Match.OneOf(Number, null)));\n\n  var table = Tabular.tablesByName[tableName];\n  if (!table) {\n    throw new Error('No TabularTable defined with the name \"' + tableName + '\". Make sure you are defining your TabularTable in common code.');\n  }\n\n  // Check security. We call this in both publications.\n  // Even though we're only publishing _ids and counts\n  // from this function, with sensitive data, there is\n  // a chance someone could do a query and learn something\n  // just based on whether a result is found or not.\n  if (typeof table.allow === 'function' && !table.allow(self.userId)) {\n    self.ready();\n    return;\n  }\n\n  selector = selector || {};\n\n  // Allow the user to modify the selector before we use it\n  if (typeof table.changeSelector === 'function') {\n    selector = table.changeSelector(selector, self.userId);\n  }\n\n  // Apply the server side selector specified in the tabular\n  // table constructor. Both must be met, so we join\n  // them using $and, allowing both selectors to have\n  // the same keys.\n  if (typeof table.selector === 'function') {\n    var tableSelector = table.selector(self.userId);\n    if (_.isEmpty(selector)) {\n      selector = tableSelector;\n    } else {\n      selector = {$and: [tableSelector, selector]};\n    }\n  }\n\n  var findOptions = {\n    skip: skip,\n    fields: {_id: 1}\n  };\n\n  // `limit` may be `null`\n  if (limit > 0) {\n    findOptions.limit = limit;\n  }\n\n  // `sort` may be `null`\n  if (_.isArray(sort)) {\n    findOptions.sort = sort;\n  }\n\n  var filteredCursor = table.collection.find(selector, findOptions);\n\n  var filteredRecordIds = filteredCursor.map(function (doc) {\n    return doc._id;\n  });\n\n  var countCursor = table.collection.find(selector, {fields: {_id: 1}});\n\n  var recordReady = false;\n  function updateRecords() {\n    var currentCount = countCursor.count();\n\n    var record = {\n      ids: filteredRecordIds,\n      // count() will give us the updated total count\n      // every time. It does not take the find options\n      // limit into account.\n      recordsTotal: currentCount,\n      recordsFiltered: currentCount\n    };\n\n    if (recordReady) {\n      //console.log(\"changed\", tableName, record);\n      self.changed('tabular_records', tableName, record);\n    } else {\n      //console.log(\"added\", tableName, record);\n      self.added(\"tabular_records\", tableName, record);\n      recordReady = true;\n    }\n  }\n\n  // Handle docs being added or removed from the result set.\n  var initializing1 = true;\n  var handle1 = filteredCursor.observeChanges({\n    added: function (id) {\n      if (initializing1) {\n        return;\n      }\n\n      //console.log(\"ADDED\");\n      filteredRecordIds.push(id);\n      updateRecords();\n    },\n    removed: function (id) {\n      //console.log(\"REMOVED\");\n      filteredRecordIds = _.without(filteredRecordIds, id);\n      updateRecords();\n    }\n  });\n  initializing1 = false;\n\n  // Handle docs being added or removed from the non-limited set.\n  // This allows us to get total count available.\n  var initializing2 = true;\n  var handle2 = countCursor.observeChanges({\n    added: function () {\n      if (initializing2) {\n        return;\n      }\n      updateRecords();\n    },\n    removed: function () {\n      updateRecords();\n    }\n  });\n  initializing2 = false;\n\n  updateRecords();\n  self.ready();\n\n  // Stop observing the cursors when client unsubs.\n  // Stopping a subscription automatically takes\n  // care of sending the client any removed messages.\n  self.onStop(function () {\n    handle1.stop();\n    handle2.stop();\n  });\n});\n"]}